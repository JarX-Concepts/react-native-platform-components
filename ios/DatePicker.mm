// ios/DatePicker.mm

#import "DatePicker.h"

#import <react/renderer/components/PlatformComponentsViewSpec/ComponentDescriptors.h>
#import <react/renderer/components/PlatformComponentsViewSpec/EventEmitters.h>
#import <react/renderer/components/PlatformComponentsViewSpec/Props.h>
#import <react/renderer/components/PlatformComponentsViewSpec/RCTComponentViewHelpers.h>

#import "RCTFabricComponentsPlugins.h"

#import "PlatformComponents-Swift.h"

using namespace facebook::react;

@interface DatePicker () <RCTDatePickerViewProtocol>
@end

@implementation DatePicker {
  DatePickerView *_datePickerView;
}

+ (ComponentDescriptorProvider)componentDescriptorProvider
{
  // RNDatePickerComponentDescriptor is generated by codegen
  return concreteComponentDescriptorProvider<DatePickerComponentDescriptor>();
}

- (instancetype)initWithFrame:(CGRect)frame
{
  if (self = [super initWithFrame:frame]) {
    _datePickerView = [DatePickerView new];
    self.contentView = _datePickerView;

    __weak __typeof(self) weakSelf = self;
    _datePickerView.onChangeHandler = ^(NSNumber *ms) {
      __typeof(self) strongSelf = weakSelf;
      if (!strongSelf) {
        return;
      }

      // Build the typed event payload for onChange(timestamp)
      DatePickerEventEmitter::OnChange event{
        .timestamp = ms.doubleValue,
      };
      //strongSelf.eventEmitterTyped().onChange(event);
    };
  }
  return self;
}

- (void)layoutSubviews
{
  [super layoutSubviews];
  _datePickerView.frame = self.bounds;
}

- (void)updateProps:(Props::Shared const &)props oldProps:(Props::Shared const &)oldProps
{
  const auto &oldViewProps = *std::static_pointer_cast<DatePickerProps const>(_props);
  const auto &newViewProps = *std::static_pointer_cast<DatePickerProps const>(props);

  if (oldViewProps.date != newViewProps.date && newViewProps.date) {
    _datePickerView.date = @(newViewProps.date);
  }

  if (oldViewProps.minimumDate != newViewProps.minimumDate) {
    if (newViewProps.minimumDate) {
      _datePickerView.minimumDate = @(newViewProps.minimumDate);
    } else {
      _datePickerView.minimumDate = nil;
    }
  }

  if (oldViewProps.maximumDate != newViewProps.maximumDate) {
    if (newViewProps.maximumDate) {
      _datePickerView.maximumDate = @(newViewProps.maximumDate);
    } else {
      _datePickerView.maximumDate = nil;
    }
  }

  if (oldViewProps.mode != newViewProps.mode) {
    // mode is a std::string from TS union 'date' | 'time' | 'datetime'
    _datePickerView.mode = [NSString stringWithUTF8String:newViewProps.mode.c_str()];
  }

  if (oldViewProps.locale != newViewProps.locale) {
    if (!newViewProps.locale.empty()) {
      _datePickerView.localeIdentifier =
        [NSString stringWithUTF8String:newViewProps.locale.c_str()];
    } else {
      _datePickerView.localeIdentifier = nil;
    }
  }

  if (oldViewProps.timeZoneName != newViewProps.timeZoneName) {
    if (!newViewProps.timeZoneName.empty()) {
      _datePickerView.timeZoneName =
        [NSString stringWithUTF8String:newViewProps.timeZoneName.c_str()];
    } else {
      _datePickerView.timeZoneName = nil;
    }
  }

  [super updateProps:props oldProps:oldProps];
}

// Strongly-typed event emitter helper (like in WebView docs)
- (const DatePickerEventEmitter &)eventEmitterTyped
{
  return static_cast<const DatePickerEventEmitter &>(*_eventEmitter);
}

@end

// Factory hook for Fabric
Class<RCTComponentViewProtocol> RCTDatePickerCls(void)
{
  return DatePicker.class;
}
